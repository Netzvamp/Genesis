[{"id":0,"href":"/genesis/docs/installation/","title":"Installation","section":"Docs","content":" Install Genesis # First off all, we recommend using the latest version of Python.\nWithin the environment you want to use to work, use the following command to install Genesis:\npip install genesis Genesis is now installed. Go to the documentation overview to start to work.\n"},{"id":1,"href":"/genesis/docs/quickstart/","title":"Quickstart","section":"Docs","content":" Quickstart # Genesis can be used in three main ways. Below we will briefly address each of them.\nInbound Socket Mode # An inbound socket app made with Genesis looks like this:\nimport asyncio from genesis import Inbound async def uptime(): async with Inbound(\u0026#34;127.0.0.1\u0026#34;, 8021, \u0026#34;ClueCon\u0026#34;) as client: return await client.send(\u0026#34;uptime\u0026#34;) async def main(): response = await uptime() print(response) asyncio.run(main()) So what does this code do?\nWe create an async function with uptime name. In it, we use the Inbound class as an asynchronous context manager to connect to the freeswitch. The connection is made at address 127.0.0.1 on port 8021 and authentication is done with the ClueCon password. With the connection established, we send the uptime command to the server. In the main function, we call this function to display the command return on the screen. Incoming Event handler # An event handler app made with Genesis looks like this:\nimport asyncio from genesis import Consumer app = Consumer(\u0026#34;127.0.0.1\u0026#34;, 8021, \u0026#34;ClueCon\u0026#34;) @app.handle(\u0026#34;HEARTBEAT\u0026#34;) async def handler(event): await asyncio.sleep(0.001) print(event) asyncio.run(app.start()) So what does this code do?\nWe create an application with the Consumer class. The connection is established using the address 127.0.0.1 on port 8021 and authentication is done with the ClueCon password. We use the @app.handler decorator to define a handler function and define that it will be used to handle all HEARTBEAT events that are received. We start the consumer with the app.start() instruction. Outbound Socket Mode # An outbound socket app made with Genesis looks like this:\nimport asyncio from genesis import Outbound async def handler(session): await session.answer() await session.playback(\u0026#39;ivr/ivr-welcome\u0026#39;) await session.hangup() app = Outbound(\u0026#34;127.0.0.1\u0026#34;, 5000, handler) asyncio.run(app.start()) And the dialplan should have an entry similar to this:\n\u0026lt;extension name=\u0026#34;out socket\u0026#34;\u0026gt; \u0026lt;condition\u0026gt; \u0026lt;action application=\u0026#34;socket\u0026#34; data=\u0026#34;127.0.0.1:5000 async full\u0026#34;/\u0026gt; \u0026lt;/condition\u0026gt; \u0026lt;/extension\u0026gt; So what does this code do?\nWe define a handler function that will handle all sessions established with the application. We create an application that will listen on address 127.0.0.1, on port 5000 and will use the handler function to handle connections. We start the application with the app.start() instruction. "},{"id":2,"href":"/genesis/docs/tools/","title":"Tools","section":"Docs","content":" tools # Here we will list some methods that may be useful during the development of a Genesis project.\nCommand Line Interface # The Genesis CLI provides commands to run and manage your FreeSWITCH Event Socket applications. Below are the available commands and their usage.\nUsage # genesis [OPTIONS] COMMAND [ARGS]... Options # Option Description \u0026ndash;version Show the version and exit. genesis consumer # Run your ESL events consumer.\nUsage # genesis consumer [OPTIONS] PATH Options # Option Description Default \u0026ndash;host TEXT The host to connect on. 127.0.0.1 \u0026ndash;port INTEGER The port to connect on. 8021 \u0026ndash;password TEXT The password to authenticate on host. ClueCon \u0026ndash;app TEXT Variable that contains the Consumer app in the imported module or package. None \u0026ndash;loglevel TEXT The log level to use. info Example # genesis consumer /path/to/your/app --host 192.168.1.100 --port 8021 --password MySecretPassword --loglevel debug genesis outbound # Run your outbound services.\nUsage # genesis outbound [OPTIONS] PATH Options # Option Description Default \u0026ndash;host TEXT The host to serve on. 127.0.0.1 \u0026ndash;port INTEGER The port to serve on. 9000 \u0026ndash;app TEXT Variable that contains the Outbound app in the imported module or package. None \u0026ndash;loglevel TEXT The log level to use. info Example # genesis outbound /path/to/your/app --host 192.168.1.100 --port 9000 --loglevel debug Filtrate # When added to a function that will be used as a handler for FreeSwitch events, it ensures that this function will only process events that have the entered key and that have the value associated with that key.\nArgument Type Required Default key str True N/A value str False N/A regex bool False False Key only # @app.handle(\u0026#39;sofia::register\u0026#39;) @filtrate(\u0026#39;from-user\u0026#39;) def register(event): domain = event[\u0026#39;from-host\u0026#39;] username = event[\u0026#39;from-user\u0026#39;] date = event[\u0026#39;Event-Date-Local\u0026#39;] print(f\u0026#39;[{date}] {username}@{domain} - Registred.\u0026#39;) With key and value # @app.handle(\u0026#39;sofia::register\u0026#39;) @filtrate(\u0026#39;from-user\u0026#39;, \u0026#39;1000\u0026#39;) def register(event): domain = event[\u0026#39;from-host\u0026#39;] username = event[\u0026#39;from-user\u0026#39;] date = event[\u0026#39;Event-Date-Local\u0026#39;] print(f\u0026#39;[{date}] {username}@{domain} - Registred.\u0026#39;) With key and regex in value # @app.handle(\u0026#39;sofia::register\u0026#39;) @filtrate(\u0026#39;from-user\u0026#39;, \u0026#39;^1[0-9]{3}$\u0026#39;, regex=True) def register(event): domain = event[\u0026#39;from-host\u0026#39;] username = event[\u0026#39;from-user\u0026#39;] date = event[\u0026#39;Event-Date-Local\u0026#39;] print(f\u0026#39;[{date}] {username}@{domain} - Registred.\u0026#39;) "},{"id":3,"href":"/genesis/docs/esl-events-structure/","title":"ESL events structure","section":"Docs","content":" ESL events structure # An event message has two parts:\nA list of headers (key: value based structure). A body (optional). Example # Content-Length: 625 Content-Type: text/event-plain Job-UUID: 7f4db78a-17d7-11dd-b7a0-db4edd065621 Job-Command: originate Job-Command-Arg: sofia/default/1005%20\u0026#39;%26park\u0026#39; Event-Name: BACKGROUND_JOB Core-UUID: 42bdf272-16e6-11dd-b7a0-db4edd065621 FreeSWITCH-Hostname: ser FreeSWITCH-IPv4: 192.168.1.104 FreeSWITCH-IPv6: 127.0.0.1 Event-Date-Local: 2008-05-02%2007%3A37%3A03 Event-Date-GMT: Thu,%2001%20May%202008%2023%3A37%3A03%20GMT Event-Date-timestamp: 1209685023894968 Event-Calling-File: mod_event_socket.c Event-Calling-Function: api_exec Event-Calling-Line-Number: 609 Content-Length: 41 +OK 7f4de4bc-17d7-11dd-b7a0-db4edd065621 The first 17 lines are a set of headers and the last line is a representation of your body.\nIn genesis, events are a subclass of UserDict. Since all headers can be accessed as keys of this dictionary and the event body, if it exists, is accessible through the .body property.\nevent[\u0026#34;Core-UUID\u0026#34;] # 42bdf272-16e6-11dd-b7a0-db4edd065621 event[\u0026#34;Event-Calling-Line-Number\u0026#34;] # 609 event.body # +OK 7f4de4bc-17d7-11dd-b7a0-db4edd065621 For determinate if event has body, genesis read and parse all headers and observe if the Content-Length is present. If true, the next N sequential bytes received will be read (N being the header value) and this will be the value assigned to body.\n"}]